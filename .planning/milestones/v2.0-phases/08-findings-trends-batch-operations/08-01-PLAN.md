---
phase: 08-findings-trends-batch-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/trend-tracker/SKILL.md
  - commands/diagnose/COMMAND.md
autonomous: true
requirements:
  - TRND-01
  - TRND-02
  - TRND-03

must_haves:
  truths:
    - "After a second diagnostic scan, each finding heading in latest.md has an inline [NEW] or [RECURRING] badge"
    - "Resolved findings from the prior scan appear as a summary list at the end of latest.md"
    - "First scan produces a clean report with no trend badges and writes trends.json with null prior_scan"
    - "trends.json retains exactly 2 scan slots (current + prior) and rotates on each scan"
    - "Finding IDs are content-based (hash on file path, not line number) ensuring stability across reformats"
    - "When prior scan is 90+ days old, a staleness warning is appended to the report"
  artifacts:
    - path: "skills/trend-tracker/SKILL.md"
      provides: "Post-report aggregator that classifies findings, patches badges, writes trends.json"
      contains: "classify_finding"
    - path: "commands/diagnose/COMMAND.md"
      provides: "Updated /diagnose with trend-tracker invocation after report generation"
      contains: "trend-tracker"
  key_links:
    - from: "commands/diagnose/COMMAND.md"
      to: "skills/trend-tracker/SKILL.md"
      via: "Section 5.5 invocation after report-generator writes latest.md"
      pattern: "trend.tracker"
    - from: "skills/trend-tracker/SKILL.md"
      to: "memory/{site}/trends.json"
      via: "jq read/write for 2-slot scan rotation"
      pattern: "trends\\.json"
    - from: "skills/trend-tracker/SKILL.md"
      to: "memory/{site}/latest.md"
      via: "sed -i '' to patch inline badges on finding headings"
      pattern: "sed.*BADGE"
---

<objective>
Create the trend-tracker skill and integrate it into /diagnose so that findings are classified as [NEW] or [RECURRING] across scans, resolved findings are listed, and trend data is persisted in machine-readable trends.json.

Purpose: Enable users to see whether site health is improving or degrading over time by comparing consecutive diagnostic scans. This is the core trend tracking capability for Phase 8.

Output: skills/trend-tracker/SKILL.md (new), commands/diagnose/COMMAND.md (updated with Section 5.5)
</objective>

<execution_context>
@/Users/robertli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robertli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-findings-trends-batch-operations/08-RESEARCH.md
@skills/diagnostic-arch-narrative/SKILL.md
@skills/report-generator/SKILL.md
@commands/diagnose/COMMAND.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trend-tracker skill</name>
  <files>skills/trend-tracker/SKILL.md</files>
  <action>
Create `skills/trend-tracker/SKILL.md` as a post-report aggregator skill. Follow the same structural pattern as `skills/diagnostic-arch-narrative/SKILL.md` (aggregator that reads existing data, does NOT run new checks or connect to WordPress).

**Frontmatter:** name: trend-tracker, description explaining it runs after report-generator to classify findings and write trends.json.

**Overview section:** Explain this skill:
- Runs AFTER report-generator writes latest.md (never before)
- Reads COMBINED_FINDINGS (JSON array from /diagnose), SITE_NAME, HEALTH_GRADE, counts (CRITICAL_TOTAL, WARNING_TOTAL, INFO_TOTAL), SKILLS_COMPLETED count, SKILLS_TOTAL
- Reads existing `memory/{site}/trends.json` if it exists (for prior scan data)
- Does NOT connect to WordPress, run WP-CLI, or grep code files
- On first scan: writes trends.json with null prior_scan, does NOT patch any badges (clean report)
- On subsequent scans: classifies findings, patches inline badges, appends resolved list, writes updated trends.json

**Step 1: Check for prior scan data**
- Read `memory/${SITE_NAME}/trends.json`
- Extract `current_scan.findings` as PRIOR_FINDINGS (these become the comparison baseline)
- Extract `current_scan.scan_date` as PRIOR_SCAN_DATE
- Set IS_FIRST_SCAN=true if file does not exist

**Step 2: Staleness check**
- If not first scan and PRIOR_SCAN_DATE exists, compute days since prior scan
- Use `date -j -f "%Y-%m-%dT%H:%M:%SZ" "$PRIOR_SCAN_DATE" +%s` (macOS) with Linux fallback `date -d "$PRIOR_SCAN_DATE" +%s`
- If 90+ days: set STALENESS_NOTE="Note: Prior scan was ${DAYS_AGO} days ago — trend data may be less meaningful."

**Step 3: Classify each current finding**
- For each finding in COMBINED_FINDINGS, implement `classify_finding` with two-pass matching:
  1. Exact ID match against PRIOR_FINDINGS (by finding .id field)
  2. If no exact match, fuzzy fallback on (finding_type + file_path) — extract finding_type as everything before the last hyphen-hash segment: `echo "$FINDING_ID" | rev | cut -d'-' -f2- | rev`
  3. If either matches: RECURRING. Otherwise: NEW.
- Document the REGRESSION limitation: "REGRESSION classification requires 3+ scan history. With 2-scan retention, reappeared findings are classified as [NEW]. This is a known limitation of the 2-scan retention policy."
- Document fuzzy match risk: "Fuzzy matching on (finding_type + file_path) may produce false RECURRING classifications when multiple findings of the same type exist in the same file. This is an accepted trade-off for catching reformatted code."
- Build CLASSIFICATIONS array of {id, classification} objects

**Step 4: Identify resolved findings**
- For each finding in PRIOR_FINDINGS, check if it exists in current COMBINED_FINDINGS (exact ID or fuzzy match)
- Findings in prior but NOT in current are RESOLVED
- Collect their titles into RESOLVED_TITLES list

**Step 5: Patch latest.md with inline badges (skip on first scan)**
- Only if IS_FIRST_SCAN=false
- For each finding classification, use sed to append the badge to the heading line in latest.md
- Report headings follow format: `### {FINDING_ID}: {title}`
- sed command (macOS): `sed -i '' "s|^### ${FINDING_ID}: \(.*\)$|### ${FINDING_ID}: \1 [${BADGE}]|" "memory/${SITE_NAME}/latest.md"`
- Comment noting Linux compatibility: `# macOS: sed -i ''; Linux: sed -i (without '')`

**Step 6: Append resolved findings summary (skip on first scan)**
- Only if IS_FIRST_SCAN=false AND RESOLVED_TITLES is non-empty
- Append to end of latest.md:
  ```
  ---
  ## Resolved Since Last Scan
  The following findings from the prior scan are no longer detected:
  - {title 1}
  - {title 2}
  ```
- If STALENESS_NOTE is set, append it as a blockquote after the resolved section (or after the report if no resolved findings)

**Step 7: Write updated trends.json**
- Build CURRENT_SCAN_FINDINGS from COMBINED_FINDINGS with only tracking fields: id, title, finding_type (derived from ID), file_path (from .location), severity, content_hash (last segment of ID)
- Compute SKILL_COVERAGE as "{completed}/{total}" string
- If trends.json exists: shift current_scan to prior_scan, write new current_scan
- If first scan: write with prior_scan: null
- Use jq -n with --argjson for building the JSON
- Write to temp file first then mv to avoid partial writes: `jq ... > /tmp/trends.json.tmp && mv /tmp/trends.json.tmp "$TRENDS_FILE"`
- Schema per research: { site, updated_at, prior_scan: {scan_date, grade, critical_count, warning_count, info_count, skill_coverage, findings: [{id, title, finding_type, file_path, severity, content_hash}]}, current_scan: {same structure} }
  </action>
  <verify>
File exists at skills/trend-tracker/SKILL.md. Contains: frontmatter with name/description, classify_finding function logic, 7 steps, trends.json schema documentation, REGRESSION limitation note, sed -i '' macOS syntax, staleness check at 90 days, first-scan handling (skip badges, null prior_scan).
  </verify>
  <done>
skills/trend-tracker/SKILL.md exists as a complete post-report aggregator skill with: two-pass finding classification (exact ID then fuzzy type+path fallback), inline badge patching via sed, resolved findings summary, trends.json 2-slot rotation, first-scan clean report handling, 90-day staleness warning, and documented REGRESSION limitation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate trend-tracker into /diagnose command</name>
  <files>commands/diagnose/COMMAND.md</files>
  <action>
Read the current `commands/diagnose/COMMAND.md` and add a new Section 5.5 after the existing report generation section (Section 5). This is an additive-only change — do NOT restructure or rewrite existing sections.

**Find the insertion point:** After the report generation section completes (after latest.md is written and archived). Look for the section where report-generator skill completes and before any final output to the user.

**Add Section 5.5: Trend Tracking (Post-Report)**

Content:
```
## Section 5.5: Trend Tracking (Post-Report)

After the report is saved to `memory/{site}/latest.md`, invoke the trend-tracker skill to annotate badges and update trends.json. This step only runs if the report was generated successfully.

### Invoke Trend Tracker

Following `skills/trend-tracker/SKILL.md`:
- Pass COMBINED_FINDINGS (the same JSON array built in Section 4)
- Pass SITE_NAME (from Section 1 site resolution)
- Pass HEALTH_GRADE (computed in Section 5 by report-generator)
- Pass CRITICAL_TOTAL, WARNING_TOTAL, INFO_TOTAL (severity counts from Section 4)
- Pass SKILLS_COMPLETED (count of skills that actually ran, not skipped)
- Pass SKILLS_TOTAL (total skills attempted in this mode)
- The trend-tracker reads memory/{site}/trends.json (if exists) and memory/{site}/latest.md
- The trend-tracker writes updated memory/{site}/trends.json and patches latest.md with inline badges

Display progress:
- Before: "Updating trend history..."
- After: "Trend data updated: memory/${SITE_NAME}/trends.json"

This section runs for ALL modes (full, security-only, code-only, performance) — trend tracking is mode-agnostic. The trends.json records whatever findings the current mode produced.
```

**Also update the command description/frontmatter** if it mentions the diagnostic flow steps — add trend tracking as a post-report step in the flow description.

**Do NOT modify:**
- Any existing section numbers or content
- The skill execution arrays
- The report-generator invocation
- The archive rotation logic
  </action>
  <verify>
Read commands/diagnose/COMMAND.md and confirm: Section 5.5 exists after Section 5, references skills/trend-tracker/SKILL.md, passes all required context variables (COMBINED_FINDINGS, SITE_NAME, HEALTH_GRADE, CRITICAL_TOTAL, WARNING_TOTAL, INFO_TOTAL, SKILLS_COMPLETED, SKILLS_TOTAL), and does not alter any existing sections.
  </verify>
  <done>
commands/diagnose/COMMAND.md contains Section 5.5 that invokes the trend-tracker skill after report generation, passing all required context variables, and displaying progress feedback. All existing sections remain unchanged.
  </done>
</task>

</tasks>

<verification>
1. `skills/trend-tracker/SKILL.md` exists with proper frontmatter and complete 7-step implementation
2. `commands/diagnose/COMMAND.md` contains Section 5.5 referencing trend-tracker
3. trends.json schema matches research specification (site, updated_at, prior_scan, current_scan with findings array)
4. First scan behavior: no badges patched, trends.json written with null prior_scan
5. Second scan behavior: findings classified as NEW or RECURRING, resolved findings listed, trends.json rotated
6. Staleness warning at 90+ days documented
7. REGRESSION limitation explicitly documented as known constraint of 2-scan retention
8. macOS sed -i '' used consistently with Linux compatibility comment
</verification>

<success_criteria>
- Trend tracker skill is a complete, self-contained post-report aggregator following the diagnostic-arch-narrative aggregator pattern
- /diagnose invokes trend-tracker after report generation for all modes
- trends.json schema supports the comparison matrix needs of Plan 08-02 (grade, counts, coverage, findings)
- Finding classification uses exact ID match with fuzzy (type+path) fallback per locked user decision
</success_criteria>

<output>
After completion, create `.planning/phases/08-findings-trends-batch-operations/08-01-SUMMARY.md`
</output>
